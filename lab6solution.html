<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Lab - Lab 6 Solutions</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Prism.js CSS (Tomorrow Night Dark Theme for Code Highlighting) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
    <!-- Custom Font (Inter) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Inter', sans-serif; }
        
        /* Override Prism.js background to perfectly match our Matte Zinc theme */
        pre[class*="language-"] {
            background-color: #09090b !important; /* zinc-950 */
            border: 1px solid #27272a !important; /* zinc-800 */
            border-radius: 0.5rem !important;
            margin-top: 1rem !important;
            margin-bottom: 1rem !important;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2) !important;
        }
        
        code[class*="language-"], pre[class*="language-"] {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.875rem !important;
            text-shadow: none !important;
        }

        /* Subtle scrollbar for code blocks */
        pre[class*="language-"]::-webkit-scrollbar {
            height: 8px;
        }
        pre[class*="language-"]::-webkit-scrollbar-track {
            background: #09090b; 
            border-radius: 4px;
        }
        pre[class*="language-"]::-webkit-scrollbar-thumb {
            background: #3f3f46; 
            border-radius: 4px;
        }
        pre[class*="language-"]::-webkit-scrollbar-thumb:hover {
            background: #52525b; 
        }
    </style>
</head>
<body class="bg-zinc-950 text-zinc-300 py-8 min-h-screen selection:bg-emerald-500/30 selection:text-emerald-200">

    <div class="max-w-5xl mx-auto px-4 sm:px-6 lg:px-8">
        <!-- Back Button -->
        <a href="index.html" class="inline-flex items-center gap-2 text-zinc-400 hover:text-white transition-colors mb-6 group">
            <div class="p-2 rounded-full bg-zinc-900 border border-zinc-800 group-hover:bg-zinc-800 transition-colors">
                <i data-lucide="arrow-left" class="w-5 h-5 text-emerald-400"></i>
            </div>
            <span class="font-medium">Back to Portal</span>
        </a>

        <!-- Document Container -->
        <div class="bg-zinc-900/80 backdrop-blur-lg rounded-xl shadow-[0_0_50px_rgba(0,0,0,0.5)] overflow-hidden min-h-[800px] border border-zinc-800">
            
            <!-- Document Header -->
            <div class="bg-zinc-900 border-b border-zinc-800 px-8 py-6 relative">
                <!-- Top Gradient Accent -->
                <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-emerald-500 to-cyan-500"></div>

                <div class="flex justify-between items-start">
                    <div>
                        <span class="inline-block px-3 py-1 bg-emerald-500/10 text-emerald-400 border border-emerald-500/20 rounded-full text-xs font-bold uppercase tracking-wide mb-3 shadow-[0_0_10px_rgba(16,185,129,0.1)]">
                            Verified Solutions
                        </span>
                        <h1 class="text-3xl font-extrabold text-white mb-2 tracking-tight">Lab 6: Advanced Search</h1>
                        <div class="flex items-center gap-4 text-sm text-zinc-400">
                            <span class="flex items-center gap-1.5"><i data-lucide="check-circle" class="w-4 h-4 text-emerald-500"></i> Status: Verified</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="px-8 py-10 space-y-12">

                <!-- Q1 -->
                <div>
                    <div class="flex items-center gap-3 mb-3">
                        <span class="bg-cyan-500/10 text-cyan-400 border border-cyan-500/20 font-bold px-3 py-1 rounded text-sm">Q1</span>
                        <h3 class="font-bold text-xl text-white">8-Puzzle Problem (Shortest Path / BFS)</h3>
                    </div>
                    <p class="text-zinc-400 text-sm mb-4 leading-relaxed">
                        <strong class="text-emerald-400">Approach:</strong> Since we want the <em>minimum</em> number of moves and the cost of every move is equal (1), Breadth-First Search (BFS) is the ideal algorithm. We flatten the 3x3 board into a string to make it easily hashable in our <code>visited</code> set. We generate neighboring states by swapping '0' with adjacent tiles based on predefined index maps.
                    </p>
                    
                    <!-- Code Block mapped with Prism Language Python -->
                    <pre><code class="language-python">from collections import deque

def solve_8_puzzle(initial, target):
    # Helper to convert 2D array to a string representation
    def board_to_string(board):
        return "".join(str(num) for row in board for num in row)
    
    start_state = board_to_string(initial)
    goal_state = board_to_string(target)
    
    # Pre-defined map of valid neighbor indices for a 1D string 
    # representing a 3x3 grid (indices 0 to 8).
    neighbors = {
        0: [1, 3],       1: [0, 2, 4],    2: [1, 5],
        3: [0, 4, 6],    4: [1, 3, 5, 7], 5: [2, 4, 8],
        6: [3, 7],       7: [4, 6, 8],    8: [5, 7]
    }
    
    # Queue stores tuples of (current_state_string, number_of_moves)
    queue = deque([(start_state, 0)])
    visited = set([start_state])
    
    while queue:
        state, moves = queue.popleft()
        
        # Check if we've reached the goal
        if state == goal_state:
            return moves
            
        # Find the empty space '0'
        zero_idx = state.index('0')
        
        # Generate new states by swapping '0' with valid neighbors
        for neighbor_idx in neighbors[zero_idx]:
            state_list = list(state)
            # Swap
            state_list[zero_idx], state_list[neighbor_idx] = state_list[neighbor_idx], state_list[zero_idx]
            new_state = "".join(state_list)
            
            if new_state not in visited:
                visited.add(new_state)
                queue.append((new_state, moves + 1))
                
    return -1 # If unreachable

# Test
initial = [[1, 2, 3], [4, 0, 5], [7, 8, 6]]
target = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
print(f"Minimum moves: {solve_8_puzzle(initial, target)}") # Output: 2</code></pre>
                </div>

                <hr class="border-zinc-800/80">

                <!-- Q2 -->
                <div>
                    <div class="flex items-center gap-3 mb-3">
                        <span class="bg-amber-500/10 text-amber-400 border border-amber-500/20 font-bold px-3 py-1 rounded text-sm">Q2</span>
                        <h3 class="font-bold text-xl text-white">4-Queens Simulation (Backtracking DFS)</h3>
                    </div>
                    <p class="text-zinc-400 text-sm mb-4 leading-relaxed">
                        <strong class="text-emerald-400">Approach:</strong> We use recursive Backtracking. We attempt to place one queen per row. To enforce constraints efficiently, we use three <code>sets</code> to track columns and diagonals that are under attack. Note a mathematical trick: elements on the same <em>positive diagonal</em> share the same <code>row + col</code>, and elements on the same <em>negative diagonal</em> share the same <code>row - col</code>.
                    </p>
                    
                    <!-- Code Block mapped with Prism Language Python -->
                    <pre><code class="language-python">def solveNQueens(n):
    col = set()
    posDiag = set() # (r + c)
    negDiag = set() # (r - c)
    
    res = []
    board = [["."] * n for _ in range(n)]

    def backtrack(r):
        # Base case: We placed a queen in every row successfully
        if r == n:
            copy = ["".join(row) for row in board]
            res.append(copy)
            return

        # Try placing a queen in each column of the current row 'r'
        for c in range(n):
            # Constraint check
            if c in col or (r + c) in posDiag or (r - c) in negDiag:
                continue # Skip invalid placements

            # 1. Place Queen
            col.add(c)
            posDiag.add(r + c)
            negDiag.add(r - c)
            board[r][c] = "Q"

            # 2. Explore further
            backtrack(r + 1)

            # 3. Backtrack (Remove Queen and reset constraints)
            col.remove(c)
            posDiag.remove(r + c)
            negDiag.remove(r - c)
            board[r][c] = "."

    backtrack(0)
    return res

# Test the function for N = 4
solutions = solveNQueens(4)
print(f"Total solutions found: {len(solutions)}\n")
for idx, sol in enumerate(solutions, 1):
    print(f"Solution {idx}:")
    for row in sol:
        print(row)
    print()</code></pre>
                </div>

            </div>
            
            <!-- Document Footer -->
            <div class="bg-zinc-950 border-t border-zinc-800 px-8 py-5 text-center text-zinc-600 text-sm font-medium">
                -- End of Solutions --
            </div>
        </div>
    </div>

    <!-- Initialize Icons -->
    <script>
        lucide.createIcons();
    </script>

    <!-- Prism.js Scripts for Python Syntax Highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>
