<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Lab - Lab 6 Solutions</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Custom Font (Inter) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Inter', sans-serif; }
    </style>
</head>
<body class="bg-slate-950 text-slate-900 py-8 min-h-screen">

    <div class="max-w-5xl mx-auto px-4 sm:px-6 lg:px-8">
        <!-- Back Button -->
        <a href="index.html" class="inline-flex items-center gap-2 text-slate-400 hover:text-white transition-colors mb-6 group">
            <div class="p-2 rounded-full bg-slate-800 group-hover:bg-slate-700">
                <i data-lucide="arrow-left" class="w-5 h-5"></i>
            </div>
            <span class="font-medium">Back to Portal</span>
        </a>

        <!-- Document Container -->
        <div class="bg-white rounded-xl shadow-2xl overflow-hidden min-h-[800px]">
            
            <!-- Document Header -->
            <div class="bg-cyan-50 border-b border-cyan-200 px-8 py-6">
                <div class="flex justify-between items-start">
                    <div>
                        <span class="inline-block px-3 py-1 bg-cyan-100 text-cyan-800 rounded-full text-xs font-bold uppercase tracking-wide mb-2">
                            Verified Solutions
                        </span>
                        <h1 class="text-3xl font-bold text-slate-900 mb-2">Lab 6: Advanced Search (8-Puzzle & 4-Queens)</h1>
                        <div class="flex items-center gap-4 text-sm text-slate-500">
                            <span class="flex items-center gap-1"><i data-lucide="check-circle" class="w-4 h-4"></i> Status: Verified</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="px-8 py-8 space-y-10">

                <!-- Q1 -->
                <div>
                    <div class="flex items-center gap-3 mb-2">
                        <span class="bg-blue-600 text-white font-bold px-2 py-0.5 rounded text-xs">Q1</span>
                        <h3 class="font-bold text-lg text-slate-800">8-Puzzle Problem (Shortest Path / BFS)</h3>
                    </div>
                    <p class="text-slate-600 text-sm mb-4"><strong>Approach:</strong> Since we want the <em>minimum</em> number of moves and the cost of every move is equal (1), Breadth-First Search (BFS) is the ideal algorithm. We flatten the 3x3 board into a string to make it easily hashable in our <code>visited</code> set. We generate neighboring states by swapping '0' with adjacent tiles based on predefined index maps.</p>
                    <pre class="bg-slate-900 text-slate-50 p-4 rounded-lg overflow-x-auto text-sm font-mono border border-slate-700"><code>from collections import deque

def solve_8_puzzle(initial, target):
    # Helper to convert 2D array to a string representation
    def board_to_string(board):
        return "".join(str(num) for row in board for num in row)
    
    start_state = board_to_string(initial)
    goal_state = board_to_string(target)
    
    # Pre-defined map of valid neighbor indices for a 1D string 
    # representing a 3x3 grid (indices 0 to 8).
    neighbors = {
        0: [1, 3],       1: [0, 2, 4],    2: [1, 5],
        3: [0, 4, 6],    4: [1, 3, 5, 7], 5: [2, 4, 8],
        6: [3, 7],       7: [4, 6, 8],    8: [5, 7]
    }
    
    # Queue stores tuples of (current_state_string, number_of_moves)
    queue = deque([(start_state, 0)])
    visited = set([start_state])
    
    while queue:
        state, moves = queue.popleft()
        
        # Check if we've reached the goal
        if state == goal_state:
            return moves
            
        # Find the empty space '0'
        zero_idx = state.index('0')
        
        # Generate new states by swapping '0' with valid neighbors
        for neighbor_idx in neighbors[zero_idx]:
            state_list = list(state)
            # Swap
            state_list[zero_idx], state_list[neighbor_idx] = state_list[neighbor_idx], state_list[zero_idx]
            new_state = "".join(state_list)
            
            if new_state not in visited:
                visited.add(new_state)
                queue.append((new_state, moves + 1))
                
    return -1 # If unreachable

# Test
initial = [[1, 2, 3], [4, 0, 5], [7, 8, 6]]
target = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
print("Minimum moves:", solve_8_puzzle(initial, target)) # Output: 2</code></pre>
                </div>

                <hr class="border-slate-200">

                <!-- Q2 -->
                <div>
                    <div class="flex items-center gap-3 mb-2">
                        <span class="bg-rose-600 text-white font-bold px-2 py-0.5 rounded text-xs">Q2</span>
                        <h3 class="font-bold text-lg text-slate-800">4-Queens Simulation (Backtracking DFS)</h3>
                    </div>
                    <p class="text-slate-600 text-sm mb-4"><strong>Approach:</strong> We use recursive Backtracking. We attempt to place one queen per row. To enforce constraints efficiently, we use three <code>sets</code> to track columns and diagonals that are under attack. Note a mathematical trick: elements on the same <em>positive diagonal</em> share the same <code>row + col</code>, and elements on the same <em>negative diagonal</em> share the same <code>row - col</code>.</p>
                    <pre class="bg-slate-900 text-slate-50 p-4 rounded-lg overflow-x-auto text-sm font-mono border border-slate-700"><code>def solveNQueens(n):
    col = set()
    posDiag = set() # (r + c)
    negDiag = set() # (r - c)
    
    res = []
    board = [["."] * n for _ in range(n)]

    def backtrack(r):
        # Base case: We placed a queen in every row successfully
        if r == n:
            copy = ["".join(row) for row in board]
            res.append(copy)
            return

        # Try placing a queen in each column of the current row 'r'
        for c in range(n):
            # Constraint check
            if c in col or (r + c) in posDiag or (r - c) in negDiag:
                continue # Skip invalid placements

            # 1. Place Queen
            col.add(c)
            posDiag.add(r + c)
            negDiag.add(r - c)
            board[r][c] = "Q"

            # 2. Explore further
            backtrack(r + 1)

            # 3. Backtrack (Remove Queen and reset constraints)
            col.remove(c)
            posDiag.remove(r + c)
            negDiag.remove(r - c)
            board[r][c] = "."

    backtrack(0)
    return res

# Test the function for N = 4
solutions = solveNQueens(4)
print(f"Total solutions found: {len(solutions)}\n")
for idx, sol in enumerate(solutions, 1):
    print(f"Solution {idx}:")
    for row in sol:
        print(row)
    print()</code></pre>
                </div>

            </div>
            
            <!-- Document Footer -->
            <div class="bg-cyan-50 border-t border-cyan-200 px-8 py-4 text-center text-cyan-800 text-sm">
                -- End of Solutions --
            </div>
        </div>
    </div>

    <!-- Initialize Icons -->
    <script>
        lucide.createIcons();
    </script>
</body>
</html>
