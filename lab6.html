<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Lab 6</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            /* Disable text selection by default */
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ and Edge */
            user-select: none; /* Standard syntax */
        }
        /* Allow text selection for code blocks */
        pre, code {
            -webkit-user-select: text; /* Safari */
            -ms-user-select: text; /* IE 10+ and Edge */
            user-select: text; /* Standard syntax */
        }
        details > summary {
            list-style: none;
        }
        details > summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">AI (Blind Search) & Game Programming Questions</h1>
            <p class="text-md text-gray-600 mt-2">AI Lab (1 SEP, 2025)</p>
        </header>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
            <!-- Question 1: BFS -->
            <div class="bg-white p-6 rounded-lg shadow-md hover:shadow-xl transition-shadow duration-300">
                <h2 class="text-xl font-semibold mb-3 border-b pb-2 text-blue-700">1. Graph Traversal using BFS</h2>
                <p class="mb-4">
                    Write a program to perform a Breadth-First Search (BFS) on a directed graph. Given a graph represented by an adjacency list and a starting node, your program should print the nodes in the order they are visited.
                </p>
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold mb-2">Sample Input:</h3>
                    <p class="text-sm mb-3">The input should be a dictionary or map representing the adjacency list, and an integer or string for the starting node.</p>
                    <pre class="bg-gray-200 text-gray-700 p-3 rounded-md text-sm"><code>graph = {
  'A': ['B', 'C'],
  'B': ['D', 'E'],
  'C': ['F'],
  'D': [],
  'E': ['F'],
  'F': []
}
start_node = 'A'</code></pre>
                </div>
                <div class="bg-gray-50 p-4 rounded-lg mt-4">
                    <h3 class="font-semibold mb-2">Expected Output:</h3>
                    <p class="text-sm mb-3">A list or a string showing the sequence of visited nodes.</p>
                     <pre class="bg-gray-200 text-gray-700 p-3 rounded-md text-sm"><code>['A', 'B', 'C', 'D', 'E', 'F']</code></pre>
                </div>
                <details class="mt-4 group">
                    <summary class="font-semibold text-indigo-600 cursor-pointer hover:text-indigo-800 flex items-center">
                        <span class="group-open:rotate-90 transition-transform duration-200">&#9654;</span>
                        <span class="ml-2">View Approach & Pseudocode</span>
                    </summary>
                    <div class="mt-2 pt-3 border-t">
                        <h4 class="font-semibold mb-2">Approach:</h4>
                        <p class="text-sm mb-3">Use a queue to store nodes to visit and a set to track visited nodes. Start with the root, add it to the queue and visited set. While the queue isn't empty, dequeue a node, process it, and add its unvisited neighbors to both the queue and the visited set.</p>
                        <h4 class="font-semibold mb-2">Pseudocode:</h4>
                        <pre class="bg-gray-200 text-gray-700 p-3 rounded-md text-sm"><code>function BFS(graph, startNode):
  queue = new Queue()
  visited = new Set()
  result = []

  queue.enqueue(startNode)
  visited.add(startNode)

  while queue is not empty:
    currentNode = queue.dequeue()
    result.add(currentNode)

    for each neighbor in graph[currentNode]:
      if neighbor is not in visited:
        visited.add(neighbor)
        queue.enqueue(neighbor)
  
  return result</code></pre>
                    </div>
                </details>
            </div>

            <!-- Question 2: DFS -->
            <div class="bg-white p-6 rounded-lg shadow-md hover:shadow-xl transition-shadow duration-300">
                <h2 class="text-xl font-semibold mb-3 border-b pb-2 text-blue-700">2. Path Finding using DFS</h2>
                <p class="mb-4">
                    Implement Depth-First Search (DFS) to find if a path exists in a maze. The maze is given as a 2D grid where 'S' is the start, 'E' is the end, '.' is a valid path, and '#' is a wall.
                </p>
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold mb-2">Sample Input:</h3>
                    <p class="text-sm mb-3">A 2D list or array representing the maze.</p>
                    <pre class="bg-gray-200 text-gray-700 p-3 rounded-md text-sm"><code>maze = [
  ['S', '.', '.', '#'],
  ['.', '#', '.', '#'],
  ['.', '#', '.', '.'],
  ['.', '.', '#', 'E']
]</code></pre>
                </div>
                <div class="bg-gray-50 p-4 rounded-lg mt-4">
                    <h3 class="font-semibold mb-2">Expected Output:</h3>
                    <p class="text-sm mb-3">A boolean value: `True` if a path is found, otherwise `False`.</p>
                     <pre class="bg-gray-200 text-gray-700 p-3 rounded-md text-sm"><code>True</code></pre>
                </div>
                <details class="mt-4 group">
                    <summary class="font-semibold text-indigo-600 cursor-pointer hover:text-indigo-800 flex items-center">
                        <span class="group-open:rotate-90 transition-transform duration-200">&#9654;</span>
                        <span class="ml-2">View Approach & Pseudocode</span>
                    </summary>
                    <div class="mt-2 pt-3 border-t">
                        <h4 class="font-semibold mb-2">Approach:</h4>
                        <p class="text-sm mb-3">Use recursion or a stack. From the starting point 'S', explore one neighbor as far as possible. If you hit a dead end (a wall or visited cell), backtrack and try another path. The base cases for the recursion are: finding 'E' (success), or going out of bounds/hitting a wall (failure). Mark visited cells to avoid loops.</p>
                        <h4 class="font-semibold mb-2">Pseudocode:</h4>
                        <pre class="bg-gray-200 text-gray-700 p-3 rounded-md text-sm"><code>function solveMaze(maze, row, col):
  if out_of_bounds(row, col) or maze[row][col] is '#':
    return false
  if maze[row][col] is 'E':
    return true
  if maze[row][col] is 'visited':
    return false
  
  mark maze[row][col] as 'visited'

  path_found = solveMaze(maze, row+1, col) OR
               solveMaze(maze, row-1, col) OR
               solveMaze(maze, row, col+1) OR
               solveMaze(maze, row, col-1)

  return path_found</code></pre>
                    </div>
                </details>
            </div>

            <!-- Question 3: Tic-Tac-Toe -->
            <div class="bg-white p-6 rounded-lg shadow-md hover:shadow-xl transition-shadow duration-300">
                <h2 class="text-xl font-semibold mb-3 border-b pb-2 text-green-700">3. Implement Tic-Tac-Toe Game</h2>
                <p class="mb-4">
                    Create a two-player, command-line Tic-Tac-Toe game. The program should display the 3x3 board, accept player moves, update the board, and declare a winner or a draw. It should also handle invalid moves (e.g., choosing an already occupied cell).
                </p>
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold mb-2">Sample Input:</h3>
                    <p class="text-sm mb-3">A sequence of integer inputs from 1 to 9 from two alternating players, corresponding to the board positions.</p>
                    <pre class="bg-gray-200 text-gray-700 p-3 rounded-md text-sm"><code>Player X, enter your move (1-9): 5
Player O, enter your move (1-9): 1
...and so on.</code></pre>
                </div>
                <div class="bg-gray-50 p-4 rounded-lg mt-4">
                    <h3 class="font-semibold mb-2">Expected Output:</h3>
                    <p class="text-sm mb-3">The board state printed after each move, followed by a final game-over message.</p>
                     <pre class="bg-gray-200 text-gray-700 p-3 rounded-md text-sm"><code>  |   |  
-----------
  | X |  
-----------
  |   |  
...
Player X wins!</code></pre>
                </div>
                <details class="mt-4 group">
                    <summary class="font-semibold text-indigo-600 cursor-pointer hover:text-indigo-800 flex items-center">
                        <span class="group-open:rotate-90 transition-transform duration-200">&#9654;</span>
                        <span class="ml-2">View Approach & Pseudocode</span>
                    </summary>
                    <div class="mt-2 pt-3 border-t">
                        <h4 class="font-semibold mb-2">Approach:</h4>
                        <p class="text-sm mb-3">Use a 1D or 2D array to represent the board. Create a game loop that continues until a win or draw. Inside the loop: display the board, get the current player's input, validate it, update the board state, check for a win/draw, and then switch players.</p>
                        <h4 class="font-semibold mb-2">Pseudocode:</h4>
                        <pre class="bg-gray-200 text-gray-700 p-3 rounded-md text-sm"><code>function main():
  board = create_empty_board()
  currentPlayer = 'X'

  while game_is_not_over:
    printBoard(board)
    move = getPlayerInput(currentPlayer)
    
    if isValidMove(board, move):
      updateBoard(board, move, currentPlayer)
      if checkWinner(board, currentPlayer):
        print(currentPlayer + " wins!")
        break
      if isBoardFull(board):
        print("It's a draw!")
        break
      currentPlayer = switchPlayer(currentPlayer)
    else:
      print("Invalid move.")</code></pre>
                    </div>
                </details>
            </div>

            <!-- Question 4: Card Shuffle -->
            <div class="bg-white p-6 rounded-lg shadow-md hover:shadow-xl transition-shadow duration-300">
                <h2 class="text-xl font-semibold mb-3 border-b pb-2 text-green-700">4. Shuffle a Deck of Cards in Python</h2>
                <p class="mb-4">
                   Write a Python program that creates a standard 52-card deck (4 suits, 13 ranks), and then shuffles it into a random order.
                </p>
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold mb-2">NoInputNeeded:</h3>
                    <p class="text-sm">This program does not require any user input.</p>
                </div>
                <div class="bg-gray-50 p-4 rounded-lg mt-4">
                    <h3 class="font-semibold mb-2">Expected Output:</h3>
                    <p class="text-sm mb-3">A list of 52 strings, where each string represents a card. The order of the cards in the list should be random.</p>
                     <pre class="bg-gray-200 text-gray-700 p-3 rounded-md text-sm"><code>['7 of Diamonds', 'King of Spades', '2 of Clubs', ... (and 49 other random cards)]</code></pre>
                </div>
                <details class="mt-4 group">
                    <summary class="font-semibold text-indigo-600 cursor-pointer hover:text-indigo-800 flex items-center">
                        <span class="group-open:rotate-90 transition-transform duration-200">&#9654;</span>
                        <span class="ml-2">View Approach & Pseudocode</span>
                    </summary>
                    <div class="mt-2 pt-3 border-t">
                        <h4 class="font-semibold mb-2">Approach:</h4>
                        <p class="text-sm mb-3">First, generate a list of all 52 cards. You can do this with nested loops: one for suits and one for ranks. Once you have the ordered list, use a shuffling algorithm like Fisher-Yates or a built-in library function (e.g., Python's `random.shuffle`) to randomize the list in-place.</p>
                        <h4 class="font-semibold mb-2">Pseudocode:</h4>
                        <pre class="bg-gray-200 text-gray-700 p-3 rounded-md text-sm"><code>function createDeck():
  suits = ["Hearts", "Diamonds", "Clubs", "Spades"]
  ranks = ["2", "3", "4", ..., "King", "Ace"]
  deck = new List()
  
  for each suit in suits:
    for each rank in ranks:
      deck.add(rank + " of " + suit)
  return deck

function shuffle(deck):
  // Use built-in random shuffle function
  random.shuffle(deck)

// Main execution
deck = createDeck()
shuffle(deck)
print(deck)</code></pre>
                    </div>
                </details>
            </div>
        </div>
    </div>

    <script>
        // Disable right-click context menu, but allow it on code blocks
        document.addEventListener('contextmenu', event => {
            if (!event.target.closest('pre')) {
                event.preventDefault();
            }
        });

        // Disable specific key combinations for copying, except in code blocks
        document.addEventListener('keydown', function(e) {
            // If the event target is inside a <pre> element, allow default behavior
            if (e.target.closest('pre')) {
                return;
            }

            // Disable Ctrl+C, Ctrl+X, Ctrl+U elsewhere
            if (e.ctrlKey && (e.key === 'c' || e.key === 'x' || e.key === 'u')) {
                e.preventDefault();
            }
        });
    </script>

</body>
</html>

